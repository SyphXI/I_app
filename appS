import tkinter as tk
from tkinter import ttk
from tkinter import messagebox, filedialog
import webbrowser
import pandas as pd
import paramiko
import cv2
from pyzbar.pyzbar import decode
import pyperclip
import threading
import os
from pathlib import Path
import configparser
import logging

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class AppSpaceDeviceManager:
    def __init__(self):
        # Define colors and font
        self.dominant_color = '#B6C0D0'
        self.accent_color = '#7fe1f5'
        self.error_color = '#ff6b6b'
        self.success_color = '#51cf66'
        self.standard_font = ('Arial', 18)

        # Initialize data
        self.df = None
        self.tms_names = []
        self.config = self.load_config()

        # Setup main window
        self.setup_main_window()
        self.load_device_data()
        self.create_widgets()

    def load_config(self):
        """Load configuration from file or create default config"""
        config = configparser.ConfigParser()
        config_file = 'config.ini'

        if os.path.exists(config_file):
            config.read(config_file)
        else:
            # Create default config
            config['SSH'] = {
                'username': 'admin',
                'password': 'Password',  # Consider using encrypted storage
                'timeout': '30'
            }
            config['PATHS'] = {
                'csv_file': 'Device Directory.csv',
                'screenshot_path': 'Downloads'
            }
            with open(config_file, 'w') as f:
                config.write(f)

        return config

    def load_device_data(self):
        """Load and process the CSV file with error handling"""
        csv_file = self.config.get('PATHS', 'csv_file', fallback='Device Directory.csv')

        try:
            self.df = pd.read_csv(csv_file)
            self.df_sorted = self.df.sort_values(by='Device Name', na_position='last')
            self.tms_names = self.df_sorted['Device Name'].dropna().tolist()
            logger.info(f"Loaded {len(self.tms_names)} devices from {csv_file}")
        except FileNotFoundError:
            error_msg = f"Error: '{csv_file}' not found. Please select the CSV file."
            logger.error(error_msg)
            messagebox.showerror("File Not Found", error_msg)

            # Allow user to select CSV file
            file_path = filedialog.askopenfilename(
                title="Select Device Directory CSV",
                filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
            )

            if file_path:
                try:
                    self.df = pd.read_csv(file_path)
                    self.df_sorted = self.df.sort_values(by='Device Name', na_position='last')
                    self.tms_names = self.df_sorted['Device Name'].dropna().tolist()
                    # Update config with new path
                    self.config.set('PATHS', 'csv_file', file_path)
                    with open('config.ini', 'w') as f:
                        self.config.write(f)
                except Exception as e:
                    logger.error(f"Error loading CSV: {e}")
                    messagebox.showerror("Error", f"Failed to load CSV: {e}")
                    self.tms_names = []
            else:
                self.tms_names = []

    def setup_main_window(self):
        """Initialize the main window"""
        self.root = tk.Tk()
        self.root.title("AppSpace Device Manager v2.0")
        self.root.geometry("1200x800")
        self.root.configure(bg=self.dominant_color)

        # Add menu bar
        self.create_menu()

        # Create main frame
        self.main_frame = tk.Frame(self.root, bg=self.dominant_color)
        self.main_frame.pack(fill='both', expand=True, padx=10, pady=10)

        # Configure grid weights
        for i in range(3):
            self.main_frame.columnconfigure(i, weight=1)

    def create_menu(self):
        """Create menu bar"""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        # File menu
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="Load CSV File", command=self.load_csv_file)
        file_menu.add_command(label="Refresh Data", command=self.refresh_data)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.root.quit)

        # Settings menu
        settings_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Settings", menu=settings_menu)
        settings_menu.add_command(label="SSH Settings", command=self.open_ssh_settings)

        # Help menu
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="About", command=self.show_about)

    def create_widgets(self):
        """Create all UI widgets"""
        # Device selection section
        device_frame = tk.LabelFrame(self.main_frame, text="Device Selection",
                                     font=self.standard_font, bg=self.dominant_color, fg='black')
        device_frame.grid(row=0, column=0, columnspan=3, pady=10, sticky='ew', padx=5)
        device_frame.columnconfigure(1, weight=1)

        # Autocomplete dropdown
        self.dropdown_tms_names = AutocompleteCombobox(device_frame, values=self.tms_names,
                                                       font=self.standard_font)
        self.dropdown_tms_names.set_completion_list(self.tms_names)
        self.dropdown_tms_names.grid(row=0, column=1, pady=10, padx=5, sticky='ew')

        # Device action buttons
        self.button_open_vc = tk.Button(device_frame, text="Open Appspace",
                                        command=self.open_vc_threaded,
                                        font=self.standard_font, bg=self.accent_color)
        self.button_open_vc.grid(row=0, column=0, padx=5, sticky='ew')

        self.button_show_details = tk.Button(device_frame, text="Show Details",
                                             command=self.display_vc_details,
                                             font=self.standard_font, bg=self.accent_color)
        self.button_show_details.grid(row=0, column=2, padx=5, sticky='ew')

        # Device details section
        details_frame = tk.LabelFrame(self.main_frame, text="Device Details",
                                      font=self.standard_font, bg=self.dominant_color, fg='black')
        details_frame.grid(row=1, column=0, columnspan=3, pady=10, sticky='ew', padx=5)
        details_frame.columnconfigure(0, weight=1)

        self.detail_labels = []
        detail_keys = ['Device Name', 'Device IP', 'Location', 'Device Group', 'MAC Address']
        for i, key in enumerate(detail_keys):
            label = tk.Label(details_frame, text=f"{key}: ", font=self.standard_font,
                             bg=self.dominant_color, anchor='w')
            label.grid(row=i, column=0, pady=2, sticky='ew', padx=10)
            self.detail_labels.append(label)

        # Connection section
        connection_frame = tk.LabelFrame(self.main_frame, text="Device Connection",
                                         font=self.standard_font, bg=self.dominant_color, fg='black')
        connection_frame.grid(row=2, column=0, columnspan=3, pady=10, sticky='ew', padx=5)
        connection_frame.columnconfigure(1, weight=1)

        # Username entry
        tk.Label(connection_frame, text="Username:", font=self.standard_font,
                 bg=self.dominant_color).grid(row=0, column=0, pady=5, sticky='w', padx=5)
        self.username_var = tk.StringVar(value=os.getenv('USERNAME', ''))
        self.username_box = tk.Entry(connection_frame, font=self.standard_font,
                                     textvariable=self.username_var)
        self.username_box.grid(row=0, column=1, pady=5, sticky='ew', padx=5)

        # Device IP entry
        tk.Label(connection_frame, text="Device IP:", font=self.standard_font,
                 bg=self.dominant_color).grid(row=1, column=0, pady=5, sticky='w', padx=5)
        self.chat_box = tk.Entry(connection_frame, font=self.standard_font)
        self.chat_box.grid(row=1, column=1, pady=5, sticky='ew', padx=5)

        # Action buttons section
        actions_frame = tk.LabelFrame(self.main_frame, text="Device Actions",
                                      font=self.standard_font, bg=self.dominant_color, fg='black')
        actions_frame.grid(row=3, column=0, columnspan=3, pady=10, sticky='ew', padx=5)

        for i in range(3):
            actions_frame.columnconfigure(i, weight=1)

        # Action buttons
        self.qr_code_button = tk.Button(actions_frame, text="Get Registration Code",
                                        font=self.standard_font, bg=self.accent_color,
                                        command=self.display_qr_code_data_threaded)
        self.qr_code_button.grid(row=0, column=0, pady=5, padx=5, sticky='ew')

        self.screenshot_button = tk.Button(actions_frame, text="Take Screenshot",
                                           font=self.standard_font, bg=self.accent_color,
                                           command=self.take_screenshot_threaded)
        self.screenshot_button.grid(row=0, column=1, pady=5, padx=5, sticky='ew')

        self.reboot_button = tk.Button(actions_frame, text="Reboot Device",
                                       font=self.standard_font, bg=self.error_color,
                                       command=self.reboot_device_threaded)
        self.reboot_button.grid(row=0, column=2, pady=5, padx=5, sticky='ew')

        # Status section
        status_frame = tk.Frame(self.main_frame, bg=self.dominant_color)
        status_frame.grid(row=4, column=0, columnspan=3, pady=10, sticky='ew', padx=5)
        status_frame.columnconfigure(0, weight=1)

        self.status_label = tk.Label(status_frame, text="Ready", font=self.standard_font,
                                     bg=self.dominant_color, fg='black')
        self.status_label.grid(row=0, column=0, pady=5, sticky='ew')

        self.progress_bar = ttk.Progressbar(status_frame, mode='indeterminate')
        self.progress_bar.grid(row=1, column=0, pady=5, sticky='ew')

        # Info section
        info_frame = tk.Frame(self.main_frame, bg=self.dominant_color)
        info_frame.grid(row=5, column=0, columnspan=3, pady=10, sticky='ew', padx=5)

        self.label_item_count = tk.Label(info_frame, text=f"Total Devices: {len(self.tms_names)}",
                                         font=self.standard_font, bg=self.dominant_color)
        self.label_item_count.grid(row=0, column=0, pady=5)

    def update_status(self, message, color='black'):
        """Update status label with color coding"""
        self.status_label.config(text=message, fg=color)
        logger.info(f"Status: {message}")

    def start_progress(self):
        """Start progress bar animation"""
        self.progress_bar.start(10)

    def stop_progress(self):
        """Stop progress bar animation"""
        self.progress_bar.stop()

    def display_vc_details(self):
        """Display device details"""
        tms_name = self.dropdown_tms_names.get().strip()
        if not tms_name:
            self.update_status("Please select a device", self.error_color)
            return

        if self.df is not None and tms_name in self.df['Device Name'].values:
            vc_details = self.df[self.df['Device Name'] == tms_name].iloc[0]
            detail_keys = ['Device Name', 'Device IP', 'Location', 'Device Group', 'MAC Address']

            for label, key in zip(self.detail_labels, detail_keys):
                value = vc_details.get(key, 'N/A')
                label.config(text=f"{key}: {value}")

            # Auto-populate IP address if available
            if 'Device IP' in vc_details and pd.notna(vc_details['Device IP']):
                self.chat_box.delete(0, tk.END)
                self.chat_box.insert(0, str(vc_details['Device IP']))

            self.update_status(f"Details loaded for {tms_name}", self.success_color)
        else:
            self.update_status("Device not found in database", self.error_color)

    def open_vc_threaded(self):
        """Open AppSpace in browser (threaded)"""
        threading.Thread(target=self.open_vc, daemon=True).start()

    def open_vc(self):
        """Open device in AppSpace console"""
        tms_name = self.dropdown_tms_names.get().strip()
        if not tms_name:
            self.update_status("Please select a device", self.error_color)
            return

        if self.df is not None and tms_name in self.df['Device Name'].values:
            vc_details = self.df[self.df['Device Name'] == tms_name].iloc[0]
            if 'Device Id' in vc_details and pd.notna(vc_details['Device Id']):
                url = f"https://blackrock.cloud.appspace.com/console/#!/devices/details/overview?id={vc_details['Device Id']}"
                webbrowser.open(url)
                self.update_status(f"Opened AppSpace for {tms_name}", self.success_color)
            else:
                self.update_status("Device ID not found", self.error_color)
        else:
            self.update_status("Device not found in database", self.error_color)

    def take_screenshot_threaded(self):
        """Take screenshot (threaded)"""
        threading.Thread(target=self.take_screenshot, daemon=True).start()

    def take_screenshot(self):
        """Take screenshot from device"""
        hostname = self.chat_box.get().strip()
        userid = self.username_var.get().strip()

        if not hostname or not userid:
            self.update_status("Please enter device IP and username", self.error_color)
            return

        self.start_progress()
        self.update_status("Taking screenshot...")

        try:
            # Create downloads directory if it doesn't exist
            downloads_path = Path.home() / "Downloads"
            downloads_path.mkdir(exist_ok=True)

            ssh_client = paramiko.SSHClient()
            ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

            # Get SSH credentials from config
            ssh_username = self.config.get('SSH', 'username', fallback='admin')
            ssh_password = self.config.get('SSH', 'password', fallback='Password')
            timeout = int(self.config.get('SSH', 'timeout', fallback='30'))

            ssh_client.connect(hostname=hostname, username=ssh_username,
                               password=ssh_password, timeout=timeout)
            self.update_status(f"Connected to {hostname}")

            # Send screenshot command
            stdin, stdout, stderr = ssh_client.exec_command('screenshot')
            output = stdout.read().decode()

            # Try to download screenshot files
            remote_file_paths = ['/logs/ScreenShot.bmp', '/logs/ScreenShot.png']
            downloaded = False

            for remote_file_path in remote_file_paths:
                file_extension = remote_file_path.split('.')[-1]
                local_file_path = downloads_path / f"ScreenShot.{file_extension}"

                try:
                    sftp = ssh_client.open_sftp()
                    sftp.get(remote_file_path, str(local_file_path))
                    self.update_status(f"Screenshot saved to {local_file_path}", self.success_color)
                    sftp.close()
                    downloaded = True
                    break
                except FileNotFoundError:
                    continue

            if not downloaded:
                self.update_status("No screenshot file found on device", self.error_color)

        except Exception as e:
            self.update_status(f"Screenshot failed: {str(e)}", self.error_color)
            logger.error(f"Screenshot error: {e}")
        finally:
            try:
                ssh_client.close()
            except:
                pass
            self.stop_progress()

    def display_qr_code_data_threaded(self):
        """Display QR code data (threaded)"""
        threading.Thread(target=self.display_qr_code_data, daemon=True).start()

    def display_qr_code_data(self):
        """Extract registration code from QR code"""
        userid = self.username_var.get().strip()
        if not userid:
            self.update_status("Please enter username", self.error_color)
            return

        self.start_progress()
        self.update_status("Reading QR code...")

        try:
            screenshot_path = Path.home() / "Downloads" / "ScreenShot.png"

            if not screenshot_path.exists():
                self.update_status("Screenshot not found. Take a screenshot first.", self.error_color)
                return

            # Read QR code
            image = cv2.imread(str(screenshot_path))
            if image is None:
                self.update_status("Could not read screenshot image", self.error_color)
                return

            decoded_objects = decode(image)

            if decoded_objects:
                url = decoded_objects[0].data.decode()
                registration_code = url[-6:] if len(url) >= 6 else url

                pyperclip.copy(registration_code)
                messagebox.showinfo("Registration Code",
                                    f"Registration code: {registration_code}\n\n"
                                    f"Code copied to clipboard!")
                self.update_status(f"Registration code: {registration_code}", self.success_color)
            else:
                self.update_status("No QR code found in screenshot", self.error_color)

        except Exception as e:
            self.update_status(f"QR code reading failed: {str(e)}", self.error_color)
            logger.error(f"QR code error: {e}")
        finally:
            self.stop_progress()

    def reboot_device_threaded(self):
        """Reboot device (threaded)"""
        if messagebox.askyesno("Confirm Reboot", "Are you sure you want to reboot this device?"):
            threading.Thread(target=self.reboot_device, daemon=True).start()

    def reboot_device(self):
        """Reboot the device"""
        hostname = self.chat_box.get().strip()
        if not hostname:
            self.update_status("Please enter device IP", self.error_color)
            return

        self.execute_ssh_command(hostname, 'reboot', "Reboot command sent successfully")

    def execute_ssh_command(self, ip_address, command, success_message):
        """Execute SSH command on device"""
        self.start_progress()
        self.update_status(f"Executing command: {command}")

        try:
            ssh_client = paramiko.SSHClient()
            ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

            ssh_username = self.config.get('SSH', 'username', fallback='admin')
            ssh_password = self.config.get('SSH', 'password', fallback='Blackr0ck')
            timeout = int(self.config.get('SSH', 'timeout', fallback='30'))

            ssh_client.connect(ip_address, username=ssh_username,
                               password=ssh_password, timeout=timeout)

            stdin, stdout, stderr = ssh_client.exec_command(command)
            output = stdout.read().decode()
            error = stderr.read().decode()

            if error:
                self.update_status(f"Command error: {error}", self.error_color)
            else:
                self.update_status(success_message, self.success_color)

        except Exception as e:
            self.update_status(f"SSH command failed: {str(e)}", self.error_color)
            logger.error(f"SSH error: {e}")
        finally:
            try:
                ssh_client.close()
            except:
                pass
            self.stop_progress()

    def load_csv_file(self):
        """Load a new CSV file"""
        file_path = filedialog.askopenfilename(
            title="Select Device Directory CSV",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )

        if file_path:
            try:
                self.df = pd.read_csv(file_path)
                self.df_sorted = self.df.sort_values(by='Device Name', na_position='last')
                self.tms_names = self.df_sorted['Device Name'].dropna().tolist()

                # Update dropdown
                self.dropdown_tms_names['values'] = self.tms_names
                self.dropdown_tms_names.set_completion_list(self.tms_names)

                # Update config
                self.config.set('PATHS', 'csv_file', file_path)
                with open('config.ini', 'w') as f:
                    self.config.write(f)

                self.label_item_count.config(text=f"Total Devices: {len(self.tms_names)}")
                self.update_status(f"Loaded {len(self.tms_names)} devices", self.success_color)

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load CSV: {e}")

    def refresh_data(self):
        """Refresh device data"""
        self.load_device_data()
        if hasattr(self, 'dropdown_tms_names'):
            self.dropdown_tms_names['values'] = self.tms_names
            self.dropdown_tms_names.set_completion_list(self.tms_names)
            self.label_item_count.config(text=f"Total Devices: {len(self.tms_names)}")
            self.update_status("Data refreshed", self.success_color)

    def open_ssh_settings(self):
        """Open SSH settings dialog"""
        # This would open a settings dialog - simplified for this example
        messagebox.showinfo("SSH Settings", "SSH settings dialog would open here.\n"
                                            "Current settings are stored in config.ini")

    def show_about(self):
        """Show about dialog"""
        messagebox.showinfo("About", "AppSpace Device Manager v2.0\n\n"
                                     "Enhanced device management tool for AppSpace devices.\n"
                                     "Features: Device management, SSH commands, QR code reading,\n"
                                     "screenshot capture, and more.")

    def run(self):
        """Start the application"""
        self.root.mainloop()


class AutocompleteCombobox(ttk.Combobox):
    """Enhanced autocomplete combobox"""

    def set_completion_list(self, completion_list):
        self._completion_list = sorted(completion_list, key=str.lower)
        self.bind('<KeyRelease>', self.handle_keyrelease)
        self.bind('<Button-1>', self.handle_click)

    def reset_completion_list(self):
        """Reset the completion list to the original list."""
        self['values'] = self._completion_list

    def handle_keyrelease(self, event):
        if event.keysym == "BackSpace":
            self.delete(self.index(tk.INSERT), tk.END)
        else:
            value = event.widget.get()
            if value == '':
                data = self._completion_list
            else:
                data = [item for item in self._completion_list
                        if value.lower() in item.lower()]
            self['values'] = data

        if event.keysym == "Escape":
            self.reset_completion_list()

    def handle_click(self, event):
        """Handle dropdown click"""
        self['values'] = self._completion_list


if __name__ == "__main__":
    try:
        app = AppSpaceDeviceManager()
        app.run()
    except Exception as e:
        logger.error(f"Application error: {e}")
        messagebox.showerror("Application Error", f"An error occurred: {e}")

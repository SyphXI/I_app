# screenshot_tool.py
#
# A command-line tool to automate taking screenshots from multiple devices,
# saving them into a timestamped folder, and generating an HTML gallery for easy viewing.
# This script is designed to be run from the command line and uses a config.ini
# file for settings, similar to the AppSpace Device Manager.

import os
import pandas as pd
import paramiko
import configparser
import logging
from pathlib import Path
from datetime import datetime

# --- 1. Setup Logging ---
# Configure logging to provide clear, informative output to the console.
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# --- 2. Configuration Management ---
def load_config():
    """
    Loads configuration from 'config.ini' or creates a default one if it doesn't exist.
    This is crucial for storing SSH credentials and file paths securely.
    """
    config = configparser.ConfigParser()
    config_file = 'config.ini'
    if not os.path.exists(config_file):
        logger.warning(f"'{config_file}' not found. Creating a default config file.")
        config['SSH'] = {
            'username': 'admin',
            'password': 'YourDevicePassword', # IMPORTANT: Change this!
            'timeout': '30'
        }
        config['PATHS'] = {
            'csv_file': 'Device Directory.csv',
            'output_directory': 'screenshots'
        }
        with open(config_file, 'w') as f:
            config.write(f)
        logger.info(f"Default '{config_file}' created. Please edit it with your device password and paths.")
    else:
        config.read(config_file)
    return config

# --- 3. Device Data Handling ---
def load_device_data(csv_file_path):
    """
    Reads the device information from the specified CSV file using pandas.
    The CSV should contain 'Device Name' and 'Device IP' columns.
    Returns a list of device dictionaries.
    """
    try:
        df = pd.read_csv(csv_file_path)
        # Ensure required columns exist
        if 'Device Name' not in df.columns or 'Device IP' not in df.columns:
            logger.error("CSV file must contain 'Device Name' and 'Device IP' columns.")
            return []
        # Drop rows where Device Name or Device IP is missing
        df.dropna(subset=['Device Name', 'Device IP'], inplace=True)
        # Sort by device name for consistent ordering
        df_sorted = df.sort_values(by='Device Name').reset_index(drop=True)
        devices = df_sorted[['Device Name', 'Device IP']].to_dict('records')
        logger.info(f"Successfully loaded {len(devices)} devices from '{csv_file_path}'.")
        return devices
    except FileNotFoundError:
        logger.error(f"Error: The device CSV file was not found at '{csv_file_path}'.")
        logger.error("Please ensure the 'csv_file' path in 'config.ini' is correct.")
        return []
    except Exception as e:
        logger.error(f"An error occurred while reading the CSV file: {e}")
        return []

# --- 4. Core SSH and Screenshot Logic ---
def take_screenshot_and_save(device_name, ip_address, output_dir, ssh_config):
    """
    Connects to a device via SSH, takes a screenshot, and downloads it.
    This is the core function for interacting with each device.
    """
    local_filename = f"{device_name.replace(' ', '_').replace('/', '_')}.png"
    local_filepath = output_dir / local_filename
    
    logger.info(f"[{device_name}] Attempting to connect to {ip_address}...")

    try:
        # Establish SSH connection
        with paramiko.SSHClient() as ssh_client:
            ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh_client.connect(
                hostname=ip_address,
                username=ssh_config['username'],
                password=ssh_config['password'],
                timeout=int(ssh_config['timeout'])
            )
            logger.info(f"[{device_name}] SSH connection successful.")
            
            # Execute screenshot command
            logger.info(f"[{device_name}] Executing screenshot command...")
            stdin, stdout, stderr = ssh_client.exec_command('screenshot')
            # Wait for the command to complete
            stdout.channel.recv_exit_status() 
            logger.info(f"[{device_name}] Screenshot command executed.")
            
            # Transfer the screenshot file via SFTP
            remote_paths_to_try = ['/logs/ScreenShot.png', '/logs/ScreenShot.bmp']
            downloaded = False
            with ssh_client.open_sftp() as sftp:
                for remote_path in remote_paths_to_try:
                    try:
                        logger.info(f"[{device_name}] Trying to download '{remote_path}'...")
                        sftp.get(remote_path, str(local_filepath))
                        logger.info(f"[{device_name}] Successfully downloaded screenshot to '{local_filepath}'.")
                        downloaded = True
                        break # Exit loop once a file is found and downloaded
                    except FileNotFoundError:
                        logger.warning(f"[{device_name}] Remote file not found at '{remote_path}'.")
                        continue
            
            if not downloaded:
                logger.error(f"[{device_name}] Failed to find screenshot file on the device.")
                return None

        return local_filename

    except paramiko.AuthenticationException:
        logger.error(f"[{device_name}] Authentication failed. Check username/password in 'config.ini'.")
        return None
    except paramiko.SSHException as e:
        logger.error(f"[{device_name}] SSH connection error: {e}")
        return None
    except Exception as e:
        logger.error(f"[{device_name}] An unexpected error occurred: {e}")
        return None

# --- 5. Excel and HTML Generation ---
def generate_status_excelsheets(output_dir, selected_devices, failed_devices):
    """
    Generates two Excel files: one for online (successful) devices and one for offline (failed) devices.
    """
    logger.info("Generating device status Excel sheets...")

    failed_set = set(failed_devices)
    online_devices_data = []
    offline_devices_data = []

    for device in selected_devices:
        if device['Device Name'] in failed_set:
            offline_devices_data.append(device)
        else:
            online_devices_data.append(device)

    # Create Online Devices Excel if there are any
    if online_devices_data:
        online_df = pd.DataFrame(online_devices_data)
        online_filepath = output_dir / 'online_devices.xlsx'
        online_df.to_excel(online_filepath, index=False, engine='openpyxl')
        logger.info(f"Saved online devices list to '{online_filepath}'.")

    # Create Offline Devices Excel if there are any
    if offline_devices_data:
        offline_df = pd.DataFrame(offline_devices_data)
        offline_filepath = output_dir / 'offline_devices.xlsx'
        offline_df.to_excel(offline_filepath, index=False, engine='openpyxl')
        logger.info(f"Saved offline devices list to '{offline_filepath}'.")

def generate_html_gallery(output_dir, selected_devices, failed_devices):
    """
    Generates an 'index.html' file to display captured screenshots and indicate failed connections.
    """
    if not selected_devices:
        logger.warning("No devices were selected, so no HTML gallery will be generated.")
        return

    logger.info("Generating HTML gallery...")
    html_content = """
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Device Screenshots</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 0; background-color: #f4f4f9; }
            header { background-color: #4a6da7; color: white; padding: 1rem; text-align: center; }
            h1 { margin: 0; }
            .gallery { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; padding: 20px; }
            .card { background-color: white; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); overflow: hidden; width: 400px; }
            .card.failed { background-color: #ffebee; border: 1px solid #e57373; }
            .card h2 { font-size: 1rem; padding: 10px; margin: 0; background-color: #f1f1f1; text-align: center; color: #333; }
            .card img { max-width: 100%; height: auto; display: block; }
            .status-text { padding: 40px 20px; text-align: center; font-size: 1.2rem; color: #c62828; font-weight: bold; }
            .download-links { margin-top: 1rem; }
            .download-links a {
                background-color: #ffffff;
                color: #4a6da7;
                padding: 8px 15px;
                text-decoration: none;
                border-radius: 5px;
                font-weight: bold;
                margin: 0 10px;
                transition: background-color 0.3s, color 0.3s;
                border: 1px solid #4a6da7;
            }
            .download-links a:hover {
                background-color: #4a6da7;
                color: #ffffff;
            }
        </style>
    </head>
    <body>
        <header>
            <h1>Device Screenshot Gallery</h1>
            <p>Generated on: """ + datetime.now().strftime('%Y-%m-%d %H:%M:%S') + """</p>
            <div class="download-links">
    """
    # Conditionally add download links if the files exist
    if os.path.exists(output_dir / 'online_devices.xlsx'):
        html_content += '<a href="online_devices.xlsx" download>Download Online Devices List</a>'
    if os.path.exists(output_dir / 'offline_devices.xlsx'):
        html_content += '<a href="offline_devices.xlsx" download>Download Offline Devices List</a>'

    html_content += """
            </div>
        </header>
        <div class="gallery">
    """

    # Create a set of failed device names for efficient lookup
    failed_set = set(failed_devices)
    
    # Sort devices by name for a consistent order in the gallery
    sorted_devices = sorted(selected_devices, key=lambda d: d['Device Name'])

    for device in sorted_devices:
        device_name = device['Device Name']
        
        if device_name in failed_set:
            # Create a card for a failed device
            html_content += f"""
            <div class="card failed">
                <h2>{device_name}</h2>
                <div class="status-text">Connection Failed</div>
            </div>
            """
        else:
            # Create a card for a successful device
            # Sanitize device name to match the filename format
            filename = f"{device_name.replace(' ', '_').replace('/', '_')}.png"
            html_content += f"""
            <div class="card">
                <h2>{device_name}</h2>
                <img src="{filename}" alt="Screenshot of {device_name}">
            </div>
            """

    html_content += """
        </div>
    </body>
    </html>
    """

    html_filepath = output_dir / 'index.html'
    with open(html_filepath, 'w') as f:
        f.write(html_content)
    logger.info(f"HTML gallery saved to '{html_filepath}'.")

# --- 6. Main Execution Flow ---
def main():
    """
    The main function that orchestrates the entire script's execution.
    """
    logger.info("--- Starting Multi-Device Screenshot Tool ---")
    
    # Load configuration
    config = load_config()
    ssh_config = config['SSH']
    paths_config = config['PATHS']

    # Create a timestamped output directory
    base_output_dir = Path(paths_config.get('output_directory', 'screenshots'))
    timestamp = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
    output_dir = base_output_dir / f"screenshots_{timestamp}"
    output_dir.mkdir(parents=True, exist_ok=True)
    logger.info(f"Output will be saved in: {output_dir}")
    
    # Load device data
    devices = load_device_data(paths_config['csv_file'])
    if not devices:
        logger.error("Exiting due to failure to load device data.")
        return

    # Prompt user to select devices
    print("\nAvailable Devices:")
    for i, device in enumerate(devices):
        print(f"  {i+1}: {device['Device Name']} ({device['Device IP']})")
    
    print("\nEnter the numbers of the devices to screenshot, separated by commas (e.g., 1,3,5).")
    print("Or type 'all' to select all devices.")
    
    user_input = input("> ").strip()
    selected_devices = []

    if user_input.lower() == 'all':
        selected_devices = devices
    else:
        try:
            indices = [int(i.strip()) - 1 for i in user_input.split(',')]
            for i in indices:
                if 0 <= i < len(devices):
                    selected_devices.append(devices[i])
                else:
                    print(f"Warning: Index {i+1} is out of range and will be ignored.")
        except ValueError:
            logger.error("Invalid input. Please enter numbers separated by commas.")
            return

    if not selected_devices:
        logger.warning("No devices selected. Exiting.")
        return

    logger.info(f"Starting screenshot process for {len(selected_devices)} selected device(s)...")
    
    successful_screenshots = []
    failed_devices = []

    # Loop through selected devices and take screenshots
    for device in selected_devices:
        device_name = device['Device Name']
        ip_address = device['Device IP']
        
        filename = take_screenshot_and_save(device_name, ip_address, output_dir, ssh_config)
        
        if filename:
            successful_screenshots.append(filename)
        else:
            failed_devices.append(device_name)
    
    # Generate the Excel sheets with online/offline status
    generate_status_excelsheets(output_dir, selected_devices, failed_devices)

    # Generate the HTML gallery with results for all selected devices
    generate_html_gallery(output_dir, selected_devices, failed_devices)
    
    # Final summary
    logger.info("--- Screenshot Process Complete ---")
    logger.info(f"Successfully captured: {len(successful_screenshots)} screenshot(s).")
    if failed_devices:
        logger.warning(f"Failed to capture for: {len(failed_devices)} device(s): {', '.join(failed_devices)}")
    logger.info(f"All files are located in: {output_dir}")
    logger.info("You can now share this folder or open the 'index.html' file to view the gallery.")


if __name__ == "__main__":
    main()
